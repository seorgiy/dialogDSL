С помощью DSL вы можете делать три группы вещей:<br><br>

[Простые замены](https://github.com/seorgiy/dialogDSL/blob/master/mod/Program/dialogDSL/core/simple_replace.c)<br>
Ключик $Name → поменяется на имя персонажа игрока. Тут всё просто.

[Вызов функций](https://github.com/seorgiy/dialogDSL/blob/master/mod/Program/dialogDSL/core/functions_replace.c)<br>
Ключик $funcName(arg0|arg1..arg9) → поменяется на вызов функции funcName. Важно, что функции  не те же, что в обычном коде, дабы максимально упростить восприятие текста для не-программиста. Однако и вызов обычных функций возможен с ограничениями: нельзя вызвать функцию без аргументов или с другим типом данных, кроме строковых. Зато можно вызывать функции внутри функций.
```
$rand(1|$rand(2|$rand($rand(4|3)|5))) → вернет 1,2,3,4 или 5. Можно и $rand(1|2|3|4|5), это просто демонстрация вложенности
```

[Управление регистром](https://github.com/seorgiy/blob/master/mod/Program/dialogDSL/core/text_utility.c)<br>
Вставляя в текст ^ или _, вы меняете регистр следующего символа. Важно, что это происходит в самом конце, поэтому вы можете менять регистр того, что вернет замена или функция из предыдуших пунктов.
Это удобно, если нужно получить "Месье" в начале предложения и "А вы, месье, кем будете?" где-то в середине.

Короткий список всех доступных [замен](https://github.com/seorgiy/dialogDSL/blob/master/mod/Program/dialogDSL/defines.c), сюда же их можно добавлять в будущем.

<h2>Почему бы не писать всё то же самое в файле диалога?</h2>

1. Эта логика происходит в файле с локализацией, таким образом вы можете строить фразы на русском, английском и других языках отдельно.
2. Это позволяет не сшивать реплики по ключам типа {ась} и {ся} для учёта пола персонажей. 
```
// Без DSL
// Вызов в каждом файле диалога для всех имеющихся языков
link.l1 = ""+ GetSexPhrase("Это вряд ли. ","") +"Спасибо, долж"+ GetSexPhrase("ен","на") +" откланяться.";

// С DSL
// Вызов в одном единственном файле диалога
link.l1 = StringFromKey(key_1);
// Ключи локализации
key_1
{
Спасибо, я $manWoman(должен|должна) откланяться.
}
key_1
{
Thank you, I beg my leave.
}
```
3. Переводчики могут использовать функции, не затрагивая логику квеста для всяких простых, но приятных мелочей. Например, вариаций слов в генераторных репликах.
4. DSL-функции могут принимать в себя до 10 аргументов и указывать их все необязательно. Например, функция $rand может выдать до 10 вариаций случайной реплики.
5. Возможен вызов собственных функций, для этого пишите их прямо так $myFunction(args), главное использовать только строковые аргументы.
6. DSL-замену можно произвести уже после вызова StringFromKey функции, таким образом можно вынести языковую логику из файла диалога, сохранив передачу значений.
```
// Без DSL
link.l1 = StringFromKey(key_1, FindRussianDaysString(iDays));
key_1
{
С тех пор прошло @<days>.
}

// C DSL
link.l1 = StringFromKey(key_1, 10);
key_1
{
С тех пор прошло $days(@<daysCount>|Acc)
}
→  После StringFromKey будет "С тех пор прошло $days(10|Acc)"
→  После парсера получаем  "С тех пор прошло 10 дней"
```

<h2>Как это устроено?</h2>

Основная функция DLGO вызывается в контексте открытого диалога и имеет доступ к трём объектам: персонажу игрока, NPC, с которым ведется диалог, и третьему объекту, переданному в неё в качестве аргумента, который может быть чем угодно. Таким образом DSL-функции могут обращаться к атрибутам любого из этих объектов.
Дальше происходит обычная шаблонизация, то есть мы превращаем текст в код и обратно.

<h2>Нюансы</h2>
1. Если нужно использовать скобки в тексте, прогоняемом через DSL → добавляем слэш "\(" и "\)".<br>
2. Не стоит подключать библиотеку к общим файлам игры, если вы разработчик мода. Это создаст конфликты с другими модами, использующими библиотеку. Подключайте только в рамках диалогового файла или интерфейсного, они подгружаются и выгружаются в момент обращения к ним, поэтому не конфликтуют.
